From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jendrik Eggers <jendrikeggerskapp@web.de>
Date: Thu, 2 Oct 2025 12:40:21 +0200
Subject: [PATCH] packet listener api


diff --git a/net/gommehd/cheetah/network/packet/PacketListener.java b/net/gommehd/cheetah/network/packet/PacketListener.java
new file mode 100644
index 0000000000000000000000000000000000000000..9dcbfdf02146432f8692a162393acaf1c106004f
--- /dev/null
+++ b/net/gommehd/cheetah/network/packet/PacketListener.java
@@ -0,0 +1,107 @@
+package net.gommehd.cheetah.network.packet;
+
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.Connection;
+
+/**
+ * Interface for handling network packets during their send and receive lifecycle.
+ * <p>
+ * The PacketListener interface provides methods for intercepting, modifying, or
+ * canceling packets as they are sent or received. Listeners can be used to implement
+ * custom processing logic, debugging, or packet filtering systems.
+ */
+public interface PacketListener {
+
+    /**
+     * Called when a packet is sent to a client.
+     * <p>
+     * This method is invoked before the packet is sent out through the network.
+     * Listeners can inspect, modify, or cancel the packet at this stage.
+     *
+     * @param connection the connection to which the packet is being sent, never null
+     * @param packet the packet being sent, never null
+     * @return {@link PacketResult} indicating how to handle the packet
+     */
+    default PacketResult onPacketSend(Connection connection, Packet<?> packet) {
+        return PacketResult.CONTINUE;
+    }
+
+    /**
+     * Called when a packet is received from a client.
+     * <p>
+     * This method is invoked before the packet is processed by the server. Listeners
+     * can inspect, modify, or cancel the packet at this stage.
+     *
+     * @param connection the connection from which the packet was received, never null
+     * @param packet the packet that was received, never null
+     * @return {@link PacketResult} indicating how to handle the received packet
+     */
+    default PacketResult onPacketReceive(Connection connection, Packet<?> packet) {
+        return PacketResult.CONTINUE;
+    }
+
+    /**
+     * Retrieves the priority of this listener.
+     * <p>
+     * This method allows defining the order in which listeners are executed.
+     * Listeners with higher priority values are executed before those with lower values.
+     *
+     * @return the priority level of this listener, where higher values indicate higher priority
+     */
+    default int priority() {
+        return 0;
+    }
+
+    /**
+     * Handles errors that occur during packet processing.
+     * <p>
+     * This method is invoked when an exception is thrown while handling a packet.
+     * Implementations can use this method to perform error handling, logging,
+     * or cleanup operations as necessary.
+     *
+     * @param connection the connection associated with the packet, never null
+     * @param packet the packet during which the error occurred may be null if unavailable
+     * @param exception the exception thrown during packet processing, never null
+     */
+    default void onPacketError(Connection connection, Packet<?> packet, Exception exception) {
+        // Default implementation does nothing
+    }
+
+    /**
+     * Enum representing the result of processing a network packet.
+     * <p>
+     * This enum is used to indicate the outcome of packet handling by listeners,
+     * such as whether processing should continue, be canceled, or proceed with
+     * a modified packet. It provides a mechanism to control the flow of packet
+     * processing in the packet handling pipeline.
+     */
+    enum PacketResult {
+        /**
+         * Indicates that packet processing should continue without interruption or modification.
+         * <p>
+         * This result is used to signify that the packet should proceed to the next handler
+         * in the pipeline without any changes or cancellations.
+         */
+        CONTINUE,
+
+        /**
+         * Indicates that packet processing should be canceled.
+         * <p>
+         * This result signifies that the processing of the currently handled
+         * packet should be halted. No further actions will be taken on the packet,
+         * and it will not be passed to subsequent handlers in the pipeline.
+         * This is typically used to prevent undesired processing or propagation
+         * of the packet.
+         */
+        CANCEL,
+
+        /**
+         * Indicates that packet processing should proceed with a modified packet.
+         * <p>
+         * This result is used when a packet has been altered during processing and
+         * should continue through the pipeline in its modified state. Subsequent
+         * handlers will receive and process the modified version of the packet.
+         */
+        MODIFIED
+    }
+}
diff --git a/net/gommehd/cheetah/network/packet/PacketListenerBuilder.java b/net/gommehd/cheetah/network/packet/PacketListenerBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..70c422a0af2aa70e4d62798a84079ba6ea80401d
--- /dev/null
+++ b/net/gommehd/cheetah/network/packet/PacketListenerBuilder.java
@@ -0,0 +1,483 @@
+package net.gommehd.cheetah.network.packet;
+
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.Connection;
+import java.util.*;
+import java.util.function.BiFunction;
+import java.util.function.Function;
+
+/**
+ * A builder utility class for creating packet listeners.
+ * <p>
+ * Packet listeners are used to handle packets sent and received within a network connection.
+ * This class provides two types of builders:
+ * - GlobalBuilder: For listeners that process all packet types.
+ * - SpecificBuilder: For listeners that process specific packet types.
+ * <p>
+ * Use the static methods provided by this class to create the corresponding builder.
+ */
+public class PacketListenerBuilder {
+    /**
+     * Creates a new global packet listener builder.
+     * Global listeners receive all packets, regardless of their type.
+     *
+     * @return a new instance of {@code GlobalBuilder}
+     */
+    public static GlobalBuilder createGlobal() {
+        return new GlobalBuilder();
+    }
+
+    /**
+     * Creates a new specific packet listener builder.
+     * Specific listeners handle packets of only the configured types.
+     *
+     * @return a new instance of {@code SpecificBuilder}
+     */
+    public static SpecificBuilder createSpecific() {
+        return new SpecificBuilder();
+    }
+
+    /**
+     * BaseBuilder is an abstract class that provides a foundation for constructing packet listener objects.
+     * It supports configuring common properties such as priority and error handling, which can be
+     * used across different types of listeners.
+     *
+     * @param <T> the type of the builder extending from this base class, enabling method chaining
+     */
+    protected static abstract class BaseBuilder<T extends BaseBuilder<T>> {
+        protected int priority = 0;
+        protected BiFunction<Connection, Exception, Void> errorHandler;
+
+        @SuppressWarnings("unchecked")
+        private T self() {
+            return (T) this;
+        }
+
+        /**
+         * Sets the priority for the packet listener.
+         * <p>
+         * This priority value determines the execution order of listeners,
+         * with higher values being executed earlier. The default priority is 0.
+         * Negative values are allowed to set a lower priority.
+         *
+         * @param priority the priority value to be assigned, higher values indicate higher priority
+         * @return the current builder instance for method chaining
+         */
+        public T withPriority(int priority) {
+            this.priority = priority;
+            return self();
+        }
+
+        /**
+         * Configures a custom error handler for handling exceptions that occur during packet processing.
+         * The provided handler will be invoked with the connection and exception details when an error is encountered.
+         *
+         * @param handler a {@code BiFunction} that accepts a {@code Connection} and an {@code Exception}, and
+         *                performs error-handling logic. The handler must not be {@code null}.
+         * @return the current builder instance for method chaining
+         * @throws NullPointerException if the provided {@code handler} is {@code null}
+         */
+        public T onError(BiFunction<Connection, Exception, Void> handler) {
+            this.errorHandler = Objects.requireNonNull(handler, "handler cannot be null");
+            return self();
+        }
+
+        /**
+         * Registers and enables the constructed {@link PacketListener}.
+         * <p>
+         * This method finalizes the configuration of the {@link PacketListener} and adds it
+         * to the system for handling packet events such as sending or receiving packets.
+         * Once registered, the {@link PacketListener} will begin processing packets based
+         * on its implemented logic and configured priority.
+         *
+         * @return the newly created and registered {@link PacketListener} instance
+         */
+        public abstract PacketListener register();
+
+        /**
+         * Constructs a new instance of a {@link PacketListener} based on the current configuration
+         * of the builder.
+         *
+         * <p>This method finalizes the construction of the {@link PacketListener}, applying all
+         * configured settings such as priority and error handling. The returned {@link PacketListener}
+         * can then be registered or used directly to intercept packet events.
+         *
+         * @return a fully constructed {@link PacketListener} instance ready for use
+         */
+        public abstract PacketListener build();
+    }
+
+    /**
+     * A builder for constructing global packet listeners.
+     * <p>
+     * Global listeners receive and handle all packets, regardless of their type.
+     * This builder allows configuring handlers for outgoing and incoming packets,
+     * as well as inheriting configuration options for priority and error-handling
+     * from the {@link BaseBuilder}.
+     * <p>
+     * The {@code GlobalBuilder} provides methods for defining custom send and receive handlers
+     * that will be invoked for every packet processed by the listener. The constructed listener
+     * is designed to handle all packets globally, making it a versatile tool for comprehensive
+     * packet monitoring or processing.
+     */
+    public static class GlobalBuilder extends BaseBuilder<GlobalBuilder> {
+        private BiFunction<Connection, Packet<?>, PacketListener.PacketResult> sendHandler;
+        private BiFunction<Connection, Packet<?>, PacketListener.PacketResult> receiveHandler;
+
+        /**
+         * Sets a handler for all outgoing packets.
+         * The specified handler will be invoked whenever a packet is sent.
+         *
+         * @param handler the send handler, which processes the connection, the packet,
+         *                and produces a {@link PacketListener.PacketResult}
+         * @return this builder for method chaining
+         */
+        public GlobalBuilder onSend(BiFunction<Connection, Packet<?>, PacketListener.PacketResult> handler) {
+            this.sendHandler = Objects.requireNonNull(handler, "handler cannot be null");
+            return this;
+        }
+
+        /**
+         * Sets a handler for all incoming packets.
+         * The specified handler will be invoked whenever a packet is received.
+         *
+         * @param handler the receive handler, which processes the connection, the packet,
+         *                and produces a {@link PacketListener.PacketResult}
+         * @return this builder for method chaining
+         */
+        public GlobalBuilder onReceive(BiFunction<Connection, Packet<?>, PacketListener.PacketResult> handler) {
+            this.receiveHandler = Objects.requireNonNull(handler, "handler cannot be null");
+            return this;
+        }
+
+        @Override
+        public PacketListener register() {
+            PacketListener listener = build();
+            PacketListenerRegistry.getInstance().registerGlobalListener(listener);
+            return listener;
+        }
+
+        @Override
+        public PacketListener build() {
+            return new GlobalPacketListener(priority, sendHandler, receiveHandler, errorHandler);
+        }
+    }
+
+    /**
+     * SpecificBuilder is a specialized implementation of {@link BaseBuilder}, used to construct
+     * packet listeners that handle specific packet types. It provides methods to configure
+     * behavior for particular packet types by associating them with handlers.
+     * <p>
+     * This builder is designed for creating listeners that process a defined subset of packets.
+     * During the registration phase, it ensures that the constructed listener is associated
+     * with the system's registry for handling the configured packet types.
+     */
+    public static class SpecificBuilder extends BaseBuilder<SpecificBuilder> {
+        private final Map<Class<? extends Packet<?>>, PacketTypeHandler> handlers = new HashMap<>();
+
+        /**
+         * Configures handling for a specific packet type.
+         *
+         * @param <T> the type of the packet being handled
+         * @param packetType the class object representing the packet type; cannot be null
+         * @return a builder for configuring handlers for the specified packet type
+         * @throws NullPointerException if {@code packetType} is null
+         */
+        public <T extends Packet<?>> PacketTypeHandlerBuilder<T> forPacket(Class<T> packetType) {
+            Objects.requireNonNull(packetType, "packetType cannot be null");
+            return new PacketTypeHandlerBuilder<>(this, packetType);
+        }
+
+        @Override
+        public PacketListener register() {
+            PacketListener listener = build();
+            PacketListenerRegistry registry = PacketListenerRegistry.getInstance();
+
+            for (Class<? extends Packet<?>> packetType : handlers.keySet()) {
+                registry.registerListener(packetType, listener);
+            }
+
+            return listener;
+        }
+
+        @Override
+        public PacketListener build() {
+            return new SpecificPacketListener(priority, new HashMap<>(handlers), errorHandler);
+        }
+
+        private void addHandler(Class<? extends Packet<?>> packetType, PacketTypeHandler handler) {
+            handlers.put(packetType, handler);
+        }
+    }
+
+    /**
+     * A builder for configuring and managing handlers for a specific packet type.
+     * This class is a part of the {@code PacketListenerBuilder} framework and is designed to
+     * handle the configuration of send and receive behaviors for individual packet types.
+     *
+     * @param <T> the type of the packet this builder is managing
+     */
+    public static class PacketTypeHandlerBuilder<T extends Packet<?>> {
+        private final SpecificBuilder parent;
+        private final Class<T> packetType;
+        private BiFunction<Connection, T, PacketListener.PacketResult> sendHandler;
+        private BiFunction<Connection, T, PacketListener.PacketResult> receiveHandler;
+
+        private PacketTypeHandlerBuilder(SpecificBuilder parent, Class<T> packetType) {
+            this.parent = parent;
+            this.packetType = packetType;
+        }
+
+        /**
+         * Sets the send handler for this packet type.
+         *
+         * @param handler the send handler, a {@link BiFunction} that processes a {@link Connection}
+         *                and the packet of type T, and returns a {@link PacketListener.PacketResult}
+         * @return this packet type handler builder
+         */
+        public PacketTypeHandlerBuilder<T> onSend(BiFunction<Connection, T, PacketListener.PacketResult> handler) {
+            this.sendHandler = Objects.requireNonNull(handler, "handler cannot be null");
+            return this;
+        }
+
+        /**
+         * Sets the send handler for this packet type using a single-parameter {@link Function}.
+         * The provided handler processes a packet of type T and returns a {@link PacketListener.PacketResult}.
+         *
+         * @param handler the send handler, a {@link Function} that accepts a packet of type T
+         *                and returns a {@link PacketListener.PacketResult}
+         * @return this packet type handler builder
+         */
+        public PacketTypeHandlerBuilder<T> onSend(Function<T, PacketListener.PacketResult> handler) {
+            Objects.requireNonNull(handler, "handler cannot be null");
+            return onSend((conn, packet) -> handler.apply(packet));
+        }
+
+        /**
+         * Sets the receive handler for this packet type.
+         *
+         * @param handler the receive handler, a {@link BiFunction} that processes a {@link Connection}
+         *                and the packet of type T, and returns a {@link PacketListener.PacketResult}
+         * @return this packet type handler builder
+         */
+        public PacketTypeHandlerBuilder<T> onReceive(BiFunction<Connection, T, PacketListener.PacketResult> handler) {
+            this.receiveHandler = Objects.requireNonNull(handler, "handler cannot be null");
+            return this;
+        }
+
+        /**
+         * Sets the receive handler for this packet type using a single-parameter {@link Function}.
+         * The provided handler processes a packet of type T and returns a {@link PacketListener.PacketResult}.
+         *
+         * @param handler the receive handler, a {@link Function} that accepts a packet of type T
+         *                and returns a {@link PacketListener.PacketResult}
+         * @return this packet type handler builder
+         */
+        public PacketTypeHandlerBuilder<T> onReceive(Function<T, PacketListener.PacketResult> handler) {
+            Objects.requireNonNull(handler, "handler cannot be null");
+            return onReceive((conn, packet) -> handler.apply(packet));
+        }
+
+        /**
+         * Finalizes the configuration of the packet type handler within the context
+         * of the current builder and registers it with the parent builder.
+         * <p>
+         * This method adds the configured send and receive handlers for the specified
+         * packet type to the parent builder and concludes the current builder's operation.
+         *
+         * @return the parent builder to allow further configuration at a higher level
+         */
+        public SpecificBuilder done() {
+            parent.addHandler(packetType, new PacketTypeHandler(sendHandler, receiveHandler));
+            return parent;
+        }
+
+        /**
+         * Configures a handler for a specific packet type within the current builder context.
+         *
+         * @param <U> the type of the packet being handled
+         * @param packetType the class of the packet type to be handled; cannot be null
+         * @return a builder for configuring handlers specific to the given packet type
+         * @throws NullPointerException if {@code packetType} is null
+         */
+        public <U extends Packet<?>> PacketTypeHandlerBuilder<U> forPacket(Class<U> packetType) {
+            return done().forPacket(packetType);
+        }
+
+        /**
+         * Builds and registers the packet listener.
+         * This automatically calls {@link #done()} first.
+         *
+         * @return the created and registered packet listener
+         */
+        public PacketListener register() {
+            return done().register();
+        }
+
+        /**
+         * Builds and returns a {@link PacketListener} instance.
+         * This method finalizes the current configuration by invoking {@code done().build()}.
+         *
+         * @return the constructed {@link PacketListener} instance
+         */
+        public PacketListener build() {
+            return done().build();
+        }
+    }
+
+    /**
+     * Represents a packet type handler used for processing send and receive operations
+     * of packets in a connection. It encapsulates logic for handling the transmission
+     * and reception of packets through specific handlers.
+     * <p>
+     * The handlers are represented as {@code BiFunction} objects which take a
+     * {@link Connection} and a packet of a generic type as input and return a
+     * {@link PacketListener.PacketResult}.
+     * <p>
+     * This is designed for use within packet listener systems to allow flexible handling
+     * of different packet types and their respective send and receive behaviors.
+     *
+     * @param sendHandler    a {@code BiFunction} that processes the sending of packets
+     * @param receiveHandler a {@code BiFunction} that processes the receiving of packets
+     */
+    private record PacketTypeHandler(BiFunction<Connection, ?, PacketListener.PacketResult> sendHandler,
+                                     BiFunction<Connection, ?, PacketListener.PacketResult> receiveHandler) {}
+
+    /**
+     * Represents a global packet listener that intercepts and handles both
+     * incoming and outgoing packets with specified handlers.
+     * <p>
+     * This listener operates at a global level, meaning it processes all packets
+     * regardless of their types. Custom behavior for packet handling can be
+     * defined through the provided handlers.
+     * <p>
+     * The listener implements the {@link PacketListener} interface, allowing
+     * it to hook into the packet send and receive events, as well as handle
+     * errors during packet processing.
+     * <p>
+     * Components:
+     * - Priority: Determines the execution order among multiple listeners.
+     *   Higher priority listeners are triggered first.
+     * - Send Handler: A function that processes outbound packets.
+     * - Receive Handler: A function that processes incoming packets.
+     * - Error Handler: A function that processes exceptions thrown during
+     *   packet handling and prevents propagation of unhandled errors.
+     * <p>
+     * This class ensures that no recursive error handling occurs by catching
+     * and ignoring exceptions within error handler invocations.
+     * <p>
+     * Functionality:
+     * - Processes packet sending logic via {@code sendHandler}.
+     * - Processes packet receiving logic via {@code receiveHandler}.
+     * - Handles packet-related errors through the {@code errorHandler}.
+     * <p>
+     * This listener provides default behavior to continue packet processing
+     * if no handlers are defined or in case of exceptions within the handlers.
+     */
+    private record GlobalPacketListener(int priority, BiFunction<Connection, Packet<?>, PacketResult> sendHandler,
+                                        BiFunction<Connection, Packet<?>, PacketResult> receiveHandler,
+                                        BiFunction<Connection, Exception, Void> errorHandler) implements PacketListener {
+
+        @Override
+        public PacketResult onPacketSend(Connection connection, Packet<?> packet) {
+            if (sendHandler != null) {
+                try {
+                    return sendHandler.apply(connection, packet);
+                } catch (Exception e) {
+                    handleError(connection, e);
+                }
+            }
+            return PacketResult.CONTINUE;
+        }
+
+        @Override
+        public PacketResult onPacketReceive(Connection connection, Packet<?> packet) {
+            if (receiveHandler != null) {
+                try {
+                    return receiveHandler.apply(connection, packet);
+                } catch (Exception e) {
+                    handleError(connection, e);
+                }
+            }
+            return PacketResult.CONTINUE;
+        }
+
+        @Override
+        public void onPacketError(Connection connection, Packet<?> packet, Exception exception) {
+            handleError(connection, exception);
+        }
+
+        private void handleError(Connection connection, Exception exception) {
+            if (errorHandler != null) {
+                try {
+                    errorHandler.apply(connection, exception);
+                } catch (Exception ignored) {
+                    // Prevent recursive error handling
+                }
+            }
+        }
+    }
+
+    /**
+     * An implementation of the {@link PacketListener} interface that provides
+     * specific packet-handling logic for defined packet types.
+     * <p>
+     * This implementation uses a mapping of packet classes to their respective
+     * {@link PacketTypeHandler} to determine how each packet should be processed.
+     * It supports handling of outgoing packets, incoming packets, and errors
+     * encountered during their processing.
+     * <p>
+     * Instances of this class are immutable and provide a fixed set of handlers
+     * for the specified packet types at creation time.
+     */
+    private record SpecificPacketListener(int priority, Map<Class<? extends Packet<?>>, PacketTypeHandler> handlers,
+                                          BiFunction<Connection, Exception, Void> errorHandler) implements PacketListener {
+
+        @Override
+        public PacketResult onPacketSend(Connection connection, Packet<?> packet) {
+            PacketTypeHandler handler = handlers.get(packet.getClass());
+            if (handler != null && handler.sendHandler() != null) {
+                try {
+                    @SuppressWarnings("unchecked")
+                    BiFunction<Connection, Packet<?>, PacketResult> castedHandler =
+                        (BiFunction<Connection, Packet<?>, PacketResult>) handler.sendHandler();
+                    return castedHandler.apply(connection, packet);
+                } catch (Exception e) {
+                    handleError(connection, e);
+                }
+            }
+            return PacketResult.CONTINUE;
+        }
+
+        @Override
+        public PacketResult onPacketReceive(Connection connection, Packet<?> packet) {
+            PacketTypeHandler handler = handlers.get(packet.getClass());
+            if (handler != null && handler.receiveHandler() != null) {
+                try {
+                    @SuppressWarnings("unchecked")
+                    BiFunction<Connection, Packet<?>, PacketResult> castedHandler =
+                        (BiFunction<Connection, Packet<?>, PacketResult>) handler.receiveHandler();
+                    return castedHandler.apply(connection, packet);
+                } catch (Exception e) {
+                    handleError(connection, e);
+                }
+            }
+            return PacketResult.CONTINUE;
+        }
+
+        @Override
+        public void onPacketError(Connection connection, Packet<?> packet, Exception exception) {
+            handleError(connection, exception);
+        }
+
+        private void handleError(Connection connection, Exception exception) {
+            if (errorHandler != null) {
+                try {
+                    errorHandler.apply(connection, exception);
+                } catch (Exception ignored) {
+                    // Prevent recursive error handling
+                }
+            }
+        }
+    }
+}
diff --git a/net/gommehd/cheetah/network/packet/PacketListenerRegistry.java b/net/gommehd/cheetah/network/packet/PacketListenerRegistry.java
new file mode 100644
index 0000000000000000000000000000000000000000..c9ce4ad852d6fa9e57c7d681f0e4ac9de34e685e
--- /dev/null
+++ b/net/gommehd/cheetah/network/packet/PacketListenerRegistry.java
@@ -0,0 +1,398 @@
+package net.gommehd.cheetah.network.packet;
+
+import net.minecraft.network.protocol.Packet;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.function.Predicate;
+
+/**
+ * The {@code PacketListenerRegistry} class serves as a registry for managing listeners associated
+ * with various types of packets. This class supports both global and type-specific listeners, as well
+ * as listeners registered conditionally based on packet type predicates.
+ * <p>
+ * A singleton instance is provided to allow centralized management of packet listener registrations,
+ * retrievals, and removals across an application.
+ */
+public class PacketListenerRegistry {
+    private static final PacketListenerRegistry INSTANCE = new PacketListenerRegistry();
+
+    private final Map<Class<? extends Packet<?>>, List<PacketListener>> listeners = new ConcurrentHashMap<>();
+    private final List<PacketListener> globalListeners = new CopyOnWriteArrayList<>();
+    private final Map<PacketListener, Set<Class<? extends Packet<?>>>> listenerToTypes = new ConcurrentHashMap<>();
+    private final List<ConditionalListenerEntry> conditionalListeners = new CopyOnWriteArrayList<>();
+    private final Map<Class<? extends Packet<?>>, List<PacketListener>> conditionalListenerCache = new ConcurrentHashMap<>();
+
+    /**
+     * Returns the singleton instance of the PacketListenerRegistry class.
+     *
+     * @return the single instance of PacketListenerRegistry
+     */
+    public static PacketListenerRegistry getInstance() {
+        return INSTANCE;
+    }
+
+    /**
+     * Registers a listener to handle packets of the specified type.
+     * <p>
+     * The listener will be invoked whenever a packet of the given type is processed.
+     * Listeners are stored and managed internally in the registry. The order of invocation
+     * is determined by the listeners' priority.
+     * <p>
+     * The listener is also tracked internally for easier removal when unregistered.
+     *
+     * @param <T> the type of the packet to associate the listener with, must extend {@code Packet<?>}
+     * @param packetType the class object representing the type of packet the listener should handle; must not be null
+     * @param listener the listener to register; must not be null
+     * @throws NullPointerException if {@code packetType} or {@code listener} is null
+     */
+    public <T extends Packet<?>> void registerListener(Class<T> packetType, PacketListener listener) {
+        Objects.requireNonNull(packetType, "packetType cannot be null");
+        Objects.requireNonNull(listener, "listener cannot be null");
+
+        listeners.computeIfAbsent(packetType, k -> new CopyOnWriteArrayList<>())
+            .add(listener);
+        sortListenersByPriority(listeners.get(packetType));
+
+        // Track listener types for easier unregistering
+        listenerToTypes.computeIfAbsent(listener, k -> new HashSet<>()).add(packetType);
+    }
+
+    /**
+     * Registers a global listener that will be invoked for every packet type.
+     * <p>
+     * Global listeners are notified regardless of the specific type of packet
+     * being processed. The provided listener is added to the internal list of
+     * global listeners and sorted by priority.
+     *
+     * @param listener the {@link PacketListener} to register, must not be null
+     * @throws NullPointerException if the {@code listener} is null
+     */
+    public void registerGlobalListener(PacketListener listener) {
+        Objects.requireNonNull(listener, "listener cannot be null");
+
+        globalListeners.add(listener);
+        sortListenersByPriority(globalListeners);
+    }
+
+    /**
+     * Registers a listener for multiple packet types.
+     * <p>
+     * The specified listener will be notified for each packet type listed in
+     * the provided array of packet types. The listener must not be null, and
+     * the array of packet types must not contain null elements.
+     *
+     * @param listener the packet listener to register, must not be null
+     * @param packetTypes the packet types that the listener should handle
+     *                    must not be null and must not contain null elements
+     * @throws NullPointerException if listener or packetTypes is null
+     */
+    @SafeVarargs
+    public final void registerListener(PacketListener listener, Class<? extends Packet<?>>... packetTypes) {
+        Objects.requireNonNull(listener, "listener cannot be null");
+        Objects.requireNonNull(packetTypes, "packetTypes cannot be null");
+
+        for (Class<? extends Packet<?>> packetType : packetTypes) {
+            registerListener(packetType, listener);
+        }
+    }
+
+    /**
+     * Registers a conditional packet listener based on the provided condition.
+     * <p>
+     * The listener will only be invoked for packets that match the predicate
+     * specified by the condition parameter. Conditional listeners are sorted by
+     * priority, with higher priority listeners being invoked first.
+     *
+     * @param condition the condition to be checked against packet types; must not be null
+     * @param listener the packet listener to register; must not be null
+     * @throws NullPointerException if the condition or listener is null
+     */
+    public void registerConditionalListener(Predicate<Class<? extends Packet<?>>> condition, PacketListener listener) {
+        Objects.requireNonNull(condition, "condition cannot be null");
+        Objects.requireNonNull(listener, "listener cannot be null");
+
+        conditionalListeners.add(new ConditionalListenerEntry(condition, listener));
+
+        // Clear cache since we have a new conditional listener
+        conditionalListenerCache.clear();
+
+        // Sort by priority
+        conditionalListeners.sort((a, b) -> Integer.compare(b.listener().priority(), a.listener().priority()));
+    }
+
+    /**
+     * Unregisters the specified {@link PacketListener} from all contexts in which it
+     * was previously registered. This includes global listeners, conditional listeners,
+     * and listeners for specific packet types.
+     *
+     * @param listener the {@link PacketListener} to unregister; must not be null
+     * @throws NullPointerException if the provided listener is null
+     */
+    public void unregisterListener(PacketListener listener) {
+        Objects.requireNonNull(listener, "listener cannot be null");
+
+        // Remove from global listeners
+        globalListeners.remove(listener);
+
+        // Remove from conditional listeners
+        conditionalListeners.removeIf(entry -> entry.listener().equals(listener));
+        conditionalListenerCache.clear(); // Clear cache since conditional listeners changed
+
+        // Remove from specific packet type listeners
+        Set<Class<? extends Packet<?>>> types = listenerToTypes.remove(listener);
+        if (types != null) {
+            for (Class<? extends Packet<?>> type : types) {
+                List<PacketListener> typeListeners = listeners.get(type);
+                if (typeListeners != null) {
+                    typeListeners.remove(listener);
+                    if (typeListeners.isEmpty()) {
+                        listeners.remove(type);
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Unregisters the specified listener for the given packet type.
+     * If the listener is no longer associated with any packet type,
+     * it is removed entirely from the mapping.
+     *
+     * @param packetType the class type of the packet for which the listener is to be unregistered
+     * @param listener the listener instance to be unregistered
+     * @throws NullPointerException if the packetType or listener is null
+     */
+    public void unregisterListener(Class<? extends Packet<?>> packetType, PacketListener listener) {
+        Objects.requireNonNull(packetType, "packetType cannot be null");
+        Objects.requireNonNull(listener, "listener cannot be null");
+
+        List<PacketListener> typeListeners = listeners.get(packetType);
+        if (typeListeners != null) {
+            typeListeners.remove(listener);
+            if (typeListeners.isEmpty()) {
+                listeners.remove(packetType);
+            }
+        }
+
+        Set<Class<? extends Packet<?>>> types = listenerToTypes.get(listener);
+        if (types != null) {
+            types.remove(packetType);
+            if (types.isEmpty()) {
+                listenerToTypes.remove(listener);
+            }
+        }
+    }
+
+    /**
+     * Retrieves a list of all packet listeners that are associated with the specified packet type.
+     * This method includes global listeners, type-specific listeners, and conditional listeners.
+     * It may also consider listeners registered for the superclass hierarchy of the given packet type.
+     * The resulting list is sorted by listener priority in descending order.
+     *
+     * @param packetType the class of the packet type for which listeners are being retrieved;
+     *                   must extend the {@code Packet} class and cannot be null.
+     * @return a sorted list of {@code PacketListener} objects that are associated with the
+     *         specified packet type, including all relevant types of listeners.
+     * @throws NullPointerException if the {@code packetType} is null.
+     */
+    @SuppressWarnings("unchecked")
+    public List<PacketListener> getListeners(Class<?> packetType) {
+        Objects.requireNonNull(packetType, "packetType cannot be null");
+
+        List<PacketListener> result = new ArrayList<>(globalListeners);
+
+        // Cast to the expected type - this is safe because we only register Packet subclasses
+        Class<? extends Packet<?>> safePacketType = (Class<? extends Packet<?>>) packetType;
+
+        // Add type-specific listeners
+        List<PacketListener> specificListeners = listeners.get(safePacketType);
+        if (specificListeners != null) {
+            result.addAll(specificListeners);
+        }
+
+        // Add conditional listeners (with caching)
+        List<PacketListener> conditionalListeners = getConditionalListenersForType(safePacketType);
+        result.addAll(conditionalListeners);
+
+        // Check inheritance hierarchy
+        Class<?> currentClass = packetType.getSuperclass();
+        while (currentClass != null && Packet.class.isAssignableFrom(currentClass)) {
+            @SuppressWarnings("unchecked")
+            List<PacketListener> parentListeners = listeners.get((Class<? extends Packet<?>>) currentClass);
+            if (parentListeners != null) {
+                result.addAll(parentListeners);
+            }
+            currentClass = currentClass.getSuperclass();
+        }
+
+        // Sort by priority
+        result.sort((a, b) -> Integer.compare(b.priority(), a.priority()));
+        return result;
+    }
+
+    /**
+     * Retrieves a list of PacketListener objects that match the specified packet type
+     * by evaluating their conditions. If the result is already cached, it retrieves
+     * it from the cache; otherwise, it evaluates the conditions, caches the result,
+     * and then returns it.
+     *
+     * @param packetType the class type of the packet for which the matching listeners
+     *                   are to be retrieved
+     * @return a list of PacketListener instances that are conditionally registered
+     *         and match the specified packet type
+     */
+    private List<PacketListener> getConditionalListenersForType(Class<? extends Packet<?>> packetType) {
+        // Check cache first
+        List<PacketListener> cached = conditionalListenerCache.get(packetType);
+        if (cached != null) {
+            return cached;
+        }
+
+        // Evaluate conditions and build result
+        List<PacketListener> result = new ArrayList<>();
+        for (ConditionalListenerEntry entry : conditionalListeners) {
+            if (entry.condition().test(packetType)) {
+                result.add(entry.listener());
+            }
+        }
+
+        // Cache the result
+        conditionalListenerCache.put(packetType, result);
+        return result;
+    }
+
+    /**
+     * Retrieves a set of all registered packet listeners.
+     * <p>
+     * This includes:
+     * - Global listeners that are invoked for every packet type.
+     * - Type-specific listeners registered for particular packet types.
+     * - Conditional listeners that match specific conditions.
+     * <p>
+     * The returned set includes all currently registered listeners, regardless of how they were registered.
+     *
+     * @return a set of all registered listeners, never null but may be empty.
+     */
+    public Set<PacketListener> getAllListeners() {
+        Set<PacketListener> result = new HashSet<>(globalListeners);
+        listeners.values().forEach(result::addAll);
+
+        // Add conditional listeners
+        for (ConditionalListenerEntry entry : conditionalListeners) {
+            result.add(entry.listener());
+        }
+
+        return result;
+    }
+
+    /**
+     * Retrieves the set of all registered packet types in the registry.
+     *
+     * @return a set of packet types (classes) for which listeners are registered, never null but may be empty
+     */
+    public Set<Class<? extends Packet<?>>> getRegisteredPacketTypes() {
+        return new HashSet<>(listeners.keySet());
+    }
+
+    /**
+     * Checks if the specified listener is currently registered in the registry.
+     * <p>
+     * A listener can be registered as a global listener, associated with specific
+     * packet types, or as a conditional listener based on predicates.
+     *
+     * @param listener the packet listener to check for registration; must not be null
+     * @return true if the listener is registered, false otherwise
+     * @throws NullPointerException if the listener is null
+     */
+    public boolean isListenerRegistered(PacketListener listener) {
+        Objects.requireNonNull(listener, "listener cannot be null");
+
+        if (globalListeners.contains(listener) || listenerToTypes.containsKey(listener)) {
+            return true;
+        }
+
+        // Check conditional listeners
+        return conditionalListeners.stream()
+            .anyMatch(entry -> entry.listener().equals(listener));
+    }
+
+    /**
+     * Clears all registered packet listeners and associated data.
+     * <p>
+     * This method effectively resets the state of the registry, removing:
+     * - All type-specific listeners.
+     * - All global listeners.
+     * - All listeners registered via predicates (conditional listeners).
+     * - Cached data related to conditional listeners.
+     * <p>
+     * After calling this method, no listeners will remain registered in the registry.
+     */
+    public void clear() {
+        listeners.clear();
+        globalListeners.clear();
+        listenerToTypes.clear();
+        conditionalListeners.clear();
+        conditionalListenerCache.clear();
+    }
+
+    /**
+     * Returns statistics about the current state of the registry, including conditional listeners.
+     *
+     * @return registry statistics, never null
+     */
+    public RegistryStats getStats() {
+        int totalSpecificListeners = listeners.values().stream().mapToInt(List::size).sum();
+        return new RegistryStats(
+            globalListeners.size(),
+            totalSpecificListeners,
+            listeners.size(),
+            getAllListeners().size(),
+            conditionalListeners.size()
+        );
+    }
+
+    /**
+     * Sorts a list of listeners by priority in descending order.
+     *
+     * @param listeners the list to sort must not be null
+     */
+    private void sortListenersByPriority(List<PacketListener> listeners) {
+        listeners.sort((a, b) -> Integer.compare(b.priority(), a.priority()));
+    }
+
+    /**
+     * A record representing statistics about the current state of a packet listener registry.
+     * Contains various metrics related to registered listeners and packet types.
+     *
+     * @param globalListeners      the number of global listeners registered in the registry.
+     * @param specificListeners    the number of type-specific listeners registered.
+     * @param registeredPacketTypes the number of unique packet types that have listeners.
+     * @param uniqueListeners       the number of unique listeners (shared across global, specific, and conditional).
+     * @param conditionalListeners  the number of conditional listeners registered.
+     */
+    public record RegistryStats(int globalListeners, int specificListeners, int registeredPacketTypes,
+                                    int uniqueListeners, int conditionalListeners) {}
+
+    /**
+     * Represents an entry in the {@code PacketListenerRegistry} that associates a
+     * conditional predicate with a specific {@code PacketListener}.
+     * <p>
+     * This record is used for registering conditional listeners, where a listener will only
+     * handle packets of types that satisfy the given condition.
+     * <p>
+     * The condition is specified as a {@code Predicate} applied to the {@code Class} type of
+     * the packet, allowing fine-grained control over which packets the listener should handle.
+     * <p>
+     * It is an immutable data structure designed to store the pairing of a condition and
+     * its corresponding listener for efficient processing.
+     * <p>
+     * Fields:
+     * - {@code condition}: A {@code Predicate} that tests the class type of packets.
+     * - {@code listener}: A {@code PacketListener} that will handle packets matching the condition.
+     */
+    private record ConditionalListenerEntry(
+        Predicate<Class<? extends Packet<?>>> condition,
+        PacketListener listener
+    ) {}
+}
diff --git a/net/minecraft/network/Connection.java b/net/minecraft/network/Connection.java
index 53d54aa67affc629424dbbc0f9678292734c559e..35ed85de0cf1edfbacf9b9e407ab1885f2af7c78 100644
--- a/net/minecraft/network/Connection.java
+++ b/net/minecraft/network/Connection.java
@@ -309,9 +309,50 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     }
 
     private static <T extends PacketListener> void genericsFtw(Packet<T> packet, PacketListener listener) {
+        // Cheetah start - packet listener api
+        net.gommehd.cheetah.network.packet.PacketListenerRegistry registry =
+            net.gommehd.cheetah.network.packet.PacketListenerRegistry.getInstance();
+        java.util.List<net.gommehd.cheetah.network.packet.PacketListener> packetListeners =
+            registry.getListeners(packet.getClass());
+
+        // Get the connection instance from context - this is a bit of a hack but necessary
+        Connection connection = getCurrentConnection(listener);
+
+        // Call packet receive listeners
+        for (net.gommehd.cheetah.network.packet.PacketListener packetListener : packetListeners) {
+            try {
+                net.gommehd.cheetah.network.packet.PacketListener.PacketResult result =
+                    packetListener.onPacketReceive(connection, packet);
+
+                if (result == net.gommehd.cheetah.network.packet.PacketListener.PacketResult.CANCEL) {
+                    return; // Skip packet processing
+                }
+            } catch (Exception e) {
+                LOGGER.warn("Error in packet receive listener for {}", packet.getClass().getSimpleName(), e);
+                try {
+                    packetListener.onPacketError(connection, packet, e);
+                } catch (Exception errorHandlerException) {
+                    LOGGER.error("Error in packet error handler", errorHandlerException);
+                }
+            }
+        }
+        // Cheetah end - packet listener api
         packet.handle((T)listener);
     }
 
+    // Cheetah start - packet listener api
+    // Helper method to get Connection from PacketListener context
+    @org.jspecify.annotations.Nullable
+    private static Connection getCurrentConnection(PacketListener listener) {
+        if (listener instanceof net.minecraft.server.network.ServerCommonPacketListenerImpl serverListener) {
+            return serverListener.connection;
+        }
+        // For other listener types, try to find connection through reflection or other means
+        // This is implementation-specific and may need adjustment based on your server version
+        return null;
+    }
+    // Cheetah end - packet listener api
+
     private void validateListener(ProtocolInfo<?> protocolInfo, PacketListener packetListener) {
         Objects.requireNonNull(packetListener, "packetListener");
         PacketFlow packetFlow = packetListener.flow();
@@ -485,6 +526,46 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
             packet.onPacketDispatchFinish(player, null);
             return;
         }
+        // Cheetah start - packet listener api
+        net.gommehd.cheetah.network.packet.PacketListenerRegistry registry =
+            net.gommehd.cheetah.network.packet.PacketListenerRegistry.getInstance();
+        java.util.List<net.gommehd.cheetah.network.packet.PacketListener> packetListeners =
+            registry.getListeners(packet.getClass());
+
+        // Call packet send listeners
+        boolean cancelled = false;
+        for (net.gommehd.cheetah.network.packet.PacketListener packetListener : packetListeners) {
+            try {
+                net.gommehd.cheetah.network.packet.PacketListener.PacketResult result =
+                    packetListener.onPacketSend(this, packet);
+
+                if (result == net.gommehd.cheetah.network.packet.PacketListener.PacketResult.CANCEL) {
+                    cancelled = true;
+                    break;
+                }
+            } catch (Exception e) {
+                LOGGER.warn("Error in packet send listener for {}", packet.getClass().getSimpleName(), e);
+                try {
+                    packetListener.onPacketError(this, packet, e);
+                } catch (Exception errorHandlerException) {
+                    LOGGER.error("Error in packet error handler", errorHandlerException);
+                }
+            }
+        }
+
+        if (cancelled) {
+            if (packet.hasFinishListener()) {
+                packet.onPacketDispatchFinish(player, null);
+            }
+            if (sendListener != null) {
+                // Create a completed future and notify listener safely
+                io.netty.channel.ChannelFuture completedFuture = this.channel.newSucceededFuture();
+                completedFuture.addListener(sendListener);
+            }
+            return;
+        }
+        // Cheetah end - packet listener api
+
         try {
         final ChannelFuture channelFuture;
         // Paper end - Optimize network
@@ -503,6 +584,18 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         }
         } catch (final Exception e) {
             LOGGER.error("NetworkException: {}", player, e);
+
+            // Cheetah start - packet listener api
+            // Notify packet listeners about the error
+            for (net.gommehd.cheetah.network.packet.PacketListener packetListener : packetListeners) {
+                try {
+                    packetListener.onPacketError(this, packet, e);
+                } catch (Exception errorHandlerException) {
+                    LOGGER.error("Error in packet error handler", errorHandlerException);
+                }
+            }
+            // Cheetah end - packet listener api
+
             this.disconnect(Component.translatable("disconnect.genericReason", "Internal Exception: " + e.getMessage()));
             packet.onPacketDispatchFinish(player, null);
         }
