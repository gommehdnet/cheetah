From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jendrik Eggers <jendrikeggerskapp@web.de>
Date: Thu, 2 Oct 2025 12:40:21 +0200
Subject: [PATCH] packet listener api


diff --git a/net/gommehd/cheetah/network/packet/PacketListener.java b/net/gommehd/cheetah/network/packet/PacketListener.java
new file mode 100644
index 0000000000000000000000000000000000000000..4c18215a75162267a38ab430bb8448af065a10a5
--- /dev/null
+++ b/net/gommehd/cheetah/network/packet/PacketListener.java
@@ -0,0 +1,155 @@
+package net.gommehd.cheetah.network.packet;
+
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.Connection;
+
+/**
+ * Interface for handling network packets during their send and receive lifecycle.
+ * <p>
+ * The PacketListener interface provides methods for intercepting, modifying, or
+ * canceling packets as they are sent or received. Listeners can be used to implement
+ * custom processing logic, debugging, or packet filtering systems.
+ */
+public interface PacketListener {
+
+    /**
+     * Called when a packet is being sent. This method allows the inspection
+     * or modification of the packet and determines the desired action to be
+     * performed (e.g., pass, cancel, modify).
+     *
+     * @param connection the connection through which the packet is being sent, never null
+     * @param packet the packet that is being sent, never null
+     * @return a {@link PacketProcessingResult} indicating the result of the packet processing,
+     *         such as whether the packet should be passed, canceled, or modified
+     */
+    default PacketProcessingResult onPacketSend(Connection connection, Packet<?> packet) {
+        return PacketProcessingResult.pass();
+    }
+
+    /**
+     * Called when a packet is received. This method allows inspection, modification,
+     * or determination of the action to take with the received packet.
+     *
+     * @param connection the connection through which the packet was received, never null
+     * @param packet the packet that was received, never null
+     * @return a {@link PacketProcessingResult} indicating the result of the packet processing,
+     *         such as whether the packet should be passed, canceled, or modified
+     */
+    default PacketProcessingResult onPacketReceive(Connection connection, Packet<?> packet) {
+        return PacketProcessingResult.pass();
+    }
+
+    /**
+     * Retrieves the priority level assigned to the listener.
+     * The priority determines the order in which the listener is executed
+     * relative to other listeners when processing events.
+     *
+     * @return the {@link ListenerPriority} of this listener, by default {@link ListenerPriority#NORMAL}
+     */
+    default ListenerPriority priority() {
+        return ListenerPriority.NORMAL;
+    }
+
+    /**
+     * Invoked when a packet error occurs. This method provides an opportunity to handle
+     * issues that arise during packet processing, such as exceptions encountered while
+     * sending or receiving packets.
+     *
+     * @param connection the connection associated with the packet, never null
+     * @param packet the packet involved in the error, can be null if unavailable
+     * @param exception the exception that was thrown during packet processing, never null
+     */
+    default void onPacketError(Connection connection, Packet<?> packet, Exception exception) {
+        // Default implementation does nothing
+    }
+
+    /**
+     * Represents the result of processing a network packet within a {@link PacketListener}.
+     * <p>
+     * This record encapsulates the outcome of packet processing and optionally provides
+     * a modified version of the packet.
+     * It is used to determine whether to pass the packet
+     * onward unmodified, cancel its processing entirely, or proceed with a modified version.
+     */
+    record PacketProcessingResult(PacketResult result, Packet<?> modifiedPacket) {
+        public static PacketProcessingResult pass() {
+            return new PacketProcessingResult(PacketResult.PASS, null);
+        }
+
+        public static PacketProcessingResult cancel() {
+            return new PacketProcessingResult(PacketResult.CANCEL, null);
+        }
+
+        public static PacketProcessingResult modify(Packet<?> newPacket) {
+            return new PacketProcessingResult(PacketResult.MODIFIED, newPacket);
+        }
+    }
+
+    /**
+     * Represents the outcome of a packet processing operation within the context of a {@code PacketListener}.
+     * <p>
+     * This enum defines the possible results that can be returned after handling a packet, indicating
+     * whether the packet should be passed through unaltered, canceled, or forwarded in a modified state.
+     * These outcomes are used to control the flow and behavior of packet processing in the packet handling
+     * pipeline.
+     */
+    enum PacketResult {
+        /**
+         * Indicates that the packet should pass through without any modifications or interruptions.
+         * <p>
+         * This result signifies that the currently handled packet is to proceed to the next stage
+         * of processing without any changes and without being canceled. It allows the packet to
+         * continue through the pipeline as it is.
+         */
+        PASS,
+
+        /**
+         * Indicates that packet processing should be canceled.
+         * <p>
+         * This result signifies that the processing of the currently handled
+         * packet should be halted. No further actions will be taken on the packet,
+         * and it will not be passed to subsequent handlers in the pipeline.
+         * This is typically used to prevent undesired processing or propagation
+         * of the packet.
+         */
+        CANCEL,
+
+        /**
+         * Indicates that packet processing should proceed with a modified packet.
+         * <p>
+         * This result is used when a packet has been altered during processing and
+         * should continue through the pipeline in its modified state. Subsequent
+         * handlers will receive and process the modified version of the packet.
+         */
+        MODIFIED
+    }
+
+    /**
+     * Represents different priority levels for listener execution in the system.
+     * The priority levels determine the order in which listeners are executed when processing events,
+     * with higher numeric values being executed earlier.
+     */
+    enum ListenerPriority {
+        LOWEST(0),
+
+        LOW(1),
+
+        NORMAL(2),
+
+        HIGH(3),
+
+        HIGHEST(4),
+
+        MONITOR(5);
+
+        private final int priority;
+
+        ListenerPriority(int priority) {
+            this.priority = priority;
+        }
+
+        public int getPriority() {
+            return priority;
+        }
+    }
+}
diff --git a/net/gommehd/cheetah/network/packet/PacketListenerBuilder.java b/net/gommehd/cheetah/network/packet/PacketListenerBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..2ea6ac20954fad43a5cd781240463038c4ad7c98
--- /dev/null
+++ b/net/gommehd/cheetah/network/packet/PacketListenerBuilder.java
@@ -0,0 +1,470 @@
+package net.gommehd.cheetah.network.packet;
+
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.Connection;
+import java.util.*;
+import java.util.function.BiFunction;
+import java.util.function.Function;
+
+/**
+ * A builder utility class for creating packet listeners.
+ * <p>
+ * Packet listeners are used to handle packets sent and received within a network connection.
+ * This class provides two types of builders:
+ * - GlobalBuilder: For listeners that process all packet types.
+ * - SpecificBuilder: For listeners that process specific packet types.
+ * <p>
+ * Use the static methods provided by this class to create the corresponding builder.
+ */
+public class PacketListenerBuilder {
+    /**
+     * Creates a new global packet listener builder.
+     * Global listeners receive all packets, regardless of their type.
+     *
+     * @return a new instance of {@code GlobalBuilder}
+     */
+    public static GlobalBuilder createGlobal() {
+        return new GlobalBuilder();
+    }
+
+    /**
+     * Creates a new specific packet listener builder.
+     * Specific listeners handle packets of only the configured types.
+     *
+     * @return a new instance of {@code SpecificBuilder}
+     */
+    public static SpecificBuilder createSpecific() {
+        return new SpecificBuilder();
+    }
+
+    /**
+     * BaseBuilder is an abstract class that provides a foundation for constructing packet listener objects.
+     * It supports configuring common properties such as priority and error handling, which can be
+     * used across different types of listeners.
+     *
+     * @param <T> the type of the builder extending from this base class, enabling method chaining
+     */
+    protected static abstract class BaseBuilder<T extends BaseBuilder<T>> {
+        protected PacketListener.ListenerPriority priority = PacketListener.ListenerPriority.NORMAL;
+        protected BiFunction<Connection, Exception, Void> errorHandler;
+
+        @SuppressWarnings("unchecked")
+        private T self() {
+            return (T) this;
+        }
+
+        /**
+         * Sets the priority level for the packet listener.
+         * The priority determines the order in which the listener will
+         * handle events relative to other listeners.
+         * Higher priorities
+         * are executed before lower ones.
+         *
+         * @param priority the {@code ListenerPriority} to assign to the packet listener
+         * @return the current builder instance for method chaining
+         */
+        public T withPriority(PacketListener.ListenerPriority priority) {
+            this.priority = priority;
+            return self();
+        }
+
+        /**
+         * Configures a custom error handler for handling exceptions that occur during packet processing.
+         * The provided handler will be invoked with the connection and exception details when an error is encountered.
+         *
+         * @param handler a {@code BiFunction} that accepts a {@code Connection} and an {@code Exception}, and
+         *                performs error-handling logic. The handler must not be {@code null}.
+         * @return the current builder instance for method chaining
+         * @throws NullPointerException if the provided {@code handler} is {@code null}
+         */
+        public T onError(BiFunction<Connection, Exception, Void> handler) {
+            this.errorHandler = Objects.requireNonNull(handler, "handler cannot be null");
+            return self();
+        }
+
+        /**
+         * Registers and enables the constructed {@link PacketListener}.
+         * <p>
+         * This method finalizes the configuration of the {@link PacketListener} and adds it
+         * to the system for handling packet events such as sending or receiving packets.
+         * Once registered, the {@link PacketListener} will begin processing packets based
+         * on its implemented logic and configured priority.
+         *
+         * @return the newly created and registered {@link PacketListener} instance
+         */
+        public abstract PacketListener register();
+
+        /**
+         * Constructs a new instance of a {@link PacketListener} based on the current configuration
+         * of the builder.
+         *
+         * <p>This method finalizes the construction of the {@link PacketListener}, applying all
+         * configured settings such as priority and error handling. The returned {@link PacketListener}
+         * can then be registered or used directly to intercept packet events.
+         *
+         * @return a fully constructed {@link PacketListener} instance ready for use
+         */
+        public abstract PacketListener build();
+    }
+
+    /**
+     * A builder for constructing global packet listeners.
+     * <p>
+     * Global listeners receive and handle all packets, regardless of their type.
+     * This builder allows configuring handlers for outgoing and incoming packets,
+     * as well as inheriting configuration options for priority and error-handling
+     * from the {@link BaseBuilder}.
+     * <p>
+     * The {@code GlobalBuilder} provides methods for defining custom send and receive handlers
+     * that will be invoked for every packet processed by the listener. The constructed listener
+     * is designed to handle all packets globally, making it a versatile tool for comprehensive
+     * packet monitoring or processing.
+     */
+    public static class GlobalBuilder extends BaseBuilder<GlobalBuilder> {
+        private BiFunction<Connection, Packet<?>, PacketListener.PacketProcessingResult> sendHandler;
+        private BiFunction<Connection, Packet<?>, PacketListener.PacketProcessingResult> receiveHandler;
+
+        /**
+         * Sets a handler for all outgoing packets.
+         * The specified handler will be invoked whenever a packet is sent.
+         *
+         * @param handler the send handler, which processes the connection, the packet,
+         *                and produces a {@link PacketListener.PacketProcessingResult}
+         * @return this builder for method chaining
+         */
+        public GlobalBuilder onSend(BiFunction<Connection, Packet<?>, PacketListener.PacketProcessingResult> handler) {
+            this.sendHandler = Objects.requireNonNull(handler, "handler cannot be null");
+            return this;
+        }
+
+        /**
+         * Sets a handler for all incoming packets.
+         * The specified handler will be invoked whenever a packet is received.
+         *
+         * @param handler the receive handler, which processes the connection, the packet,
+         *                and produces a {@link PacketListener.PacketProcessingResult}
+         * @return this builder for method chaining
+         */
+        public GlobalBuilder onReceive(BiFunction<Connection, Packet<?>, PacketListener.PacketProcessingResult> handler) {
+            this.receiveHandler = Objects.requireNonNull(handler, "handler cannot be null");
+            return this;
+        }
+
+        @Override
+        public PacketListener register() {
+            PacketListener listener = build();
+            PacketListenerRegistry.getInstance().registerGlobalListener(listener);
+            return listener;
+        }
+
+        @Override
+        public PacketListener build() {
+            return new GlobalPacketListener(priority, sendHandler, receiveHandler, errorHandler);
+        }
+    }
+
+    /**
+     * SpecificBuilder is a specialized implementation of {@link BaseBuilder}, used to construct
+     * packet listeners that handle specific packet types. It provides methods to configure
+     * behavior for particular packet types by associating them with handlers.
+     * <p>
+     * This builder is designed for creating listeners that process a defined subset of packets.
+     * During the registration phase, it ensures that the constructed listener is associated
+     * with the system's registry for handling the configured packet types.
+     */
+    public static class SpecificBuilder extends BaseBuilder<SpecificBuilder> {
+        private final Map<Class<? extends Packet<?>>, PacketTypeHandler> handlers = new HashMap<>();
+
+        /**
+         * Configures handling for a specific packet type.
+         *
+         * @param <T> the type of the packet being handled
+         * @param packetType the class object representing the packet type; cannot be null
+         * @return a builder for configuring handlers for the specified packet type
+         * @throws NullPointerException if {@code packetType} is null
+         */
+        public <T extends Packet<?>> PacketTypeHandlerBuilder<T> forPacket(Class<T> packetType) {
+            Objects.requireNonNull(packetType, "packetType cannot be null");
+            return new PacketTypeHandlerBuilder<>(this, packetType);
+        }
+
+        @Override
+        public PacketListener register() {
+            PacketListener listener = build();
+            PacketListenerRegistry registry = PacketListenerRegistry.getInstance();
+
+            for (Class<? extends Packet<?>> packetType : handlers.keySet()) {
+                registry.registerListener(packetType, listener);
+            }
+
+            return listener;
+        }
+
+        @Override
+        public PacketListener build() {
+            return new SpecificPacketListener(priority, new HashMap<>(handlers), errorHandler);
+        }
+
+        private void addHandler(Class<? extends Packet<?>> packetType, PacketTypeHandler handler) {
+            handlers.put(packetType, handler);
+        }
+    }
+
+    /**
+     * A builder for configuring and managing handlers for a specific packet type.
+     * This class is a part of the {@code PacketListenerBuilder} framework and is designed to
+     * handle the configuration of send and receive behaviors for individual packet types.
+     *
+     * @param <T> the type of the packet this builder is managing
+     */
+    public static class PacketTypeHandlerBuilder<T extends Packet<?>> {
+        private final SpecificBuilder parent;
+        private final Class<T> packetType;
+        private BiFunction<Connection, T, PacketListener.PacketProcessingResult> sendHandler;
+        private BiFunction<Connection, T, PacketListener.PacketProcessingResult> receiveHandler;
+
+        private PacketTypeHandlerBuilder(SpecificBuilder parent, Class<T> packetType) {
+            this.parent = parent;
+            this.packetType = packetType;
+        }
+
+        /**
+         * Sets the send handler for this packet type.
+         *
+         * @param handler the send handler, a {@link BiFunction} that processes a {@link Connection}
+         *                and the packet of type T, and returns a {@link PacketListener.PacketProcessingResult}
+         * @return this packet type handler builder
+         */
+        public PacketTypeHandlerBuilder<T> onSend(BiFunction<Connection, T, PacketListener.PacketProcessingResult> handler) {
+            this.sendHandler = Objects.requireNonNull(handler, "handler cannot be null");
+            return this;
+        }
+
+        /**
+         * Sets the send handler for this packet type using a single-parameter {@link Function}.
+         * The provided handler processes a packet of type T and returns a {@link PacketListener.PacketResult}.
+         *
+         * @param handler the send handler, a {@link Function} that accepts a packet of type T
+         *                and returns a {@link PacketListener.PacketProcessingResult}
+         * @return this packet type handler builder
+         */
+        public PacketTypeHandlerBuilder<T> onSend(Function<T, PacketListener.PacketProcessingResult> handler) {
+            Objects.requireNonNull(handler, "handler cannot be null");
+            return onSend((conn, packet) -> handler.apply(packet));
+        }
+
+        /**
+         * Sets the receive handler for this packet type.
+         *
+         * @param handler the receive handler, a {@link BiFunction} that processes a {@link Connection}
+         *                and the packet of type T, and returns a {@link PacketListener.PacketProcessingResult}
+         * @return this packet type handler builder
+         */
+        public PacketTypeHandlerBuilder<T> onReceive(BiFunction<Connection, T, PacketListener.PacketProcessingResult> handler) {
+            this.receiveHandler = Objects.requireNonNull(handler, "handler cannot be null");
+            return this;
+        }
+
+        /**
+         * Sets the receive handler for this packet type using a single-parameter {@link Function}.
+         * The provided handler processes a packet of type T and returns a {@link PacketListener.PacketProcessingResult}.
+         *
+         * @param handler the receive handler, a {@link Function} that accepts a packet of type T
+         *                and returns a {@link PacketListener.PacketResult}
+         * @return this packet type handler builder
+         */
+        public PacketTypeHandlerBuilder<T> onReceive(Function<T, PacketListener.PacketProcessingResult> handler) {
+            Objects.requireNonNull(handler, "handler cannot be null");
+            return onReceive((conn, packet) -> handler.apply(packet));
+        }
+
+        /**
+         * Finalizes the configuration of the packet type handler within the context
+         * of the current builder and registers it with the parent builder.
+         * <p>
+         * This method adds the configured send and receive handlers for the specified
+         * packet type to the parent builder and concludes the current builder's operation.
+         *
+         * @return the parent builder to allow further configuration at a higher level
+         */
+        public SpecificBuilder done() {
+            parent.addHandler(packetType, new PacketTypeHandler(sendHandler, receiveHandler));
+            return parent;
+        }
+
+        /**
+         * Configures a handler for a specific packet type within the current builder context.
+         *
+         * @param <U> the type of the packet being handled
+         * @param packetType the class of the packet type to be handled; cannot be null
+         * @return a builder for configuring handlers specific to the given packet type
+         * @throws NullPointerException if {@code packetType} is null
+         */
+        public <U extends Packet<?>> PacketTypeHandlerBuilder<U> forPacket(Class<U> packetType) {
+            return done().forPacket(packetType);
+        }
+
+        /**
+         * Builds and registers the packet listener.
+         * This automatically calls {@link #done()} first.
+         *
+         * @return the created and registered packet listener
+         */
+        public PacketListener register() {
+            return done().register();
+        }
+
+        /**
+         * Builds and returns a {@link PacketListener} instance.
+         * This method finalizes the current configuration by invoking {@code done().build()}.
+         *
+         * @return the constructed {@link PacketListener} instance
+         */
+        public PacketListener build() {
+            return done().build();
+        }
+    }
+
+    /**
+     * Represents a packet type handler used for processing send and receive operations
+     * of packets in a connection. It encapsulates logic for handling the transmission
+     * and reception of packets through specific handlers.
+     * <p>
+     * The handlers are represented as {@code BiFunction} objects which take a
+     * {@link Connection} and a packet of a generic type as input and return a
+     * {@link PacketListener.PacketProcessingResult}.
+     * <p>
+     * This is designed for use within packet listener systems to allow flexible handling
+     * of different packet types and their respective send and receive behaviors.
+     *
+     * @param sendHandler    a {@code BiFunction} that processes the sending of packets
+     * @param receiveHandler a {@code BiFunction} that processes the receiving of packets
+     */
+    private record PacketTypeHandler(BiFunction<Connection, ?, PacketListener.PacketProcessingResult> sendHandler,
+                                     BiFunction<Connection, ?, PacketListener.PacketProcessingResult> receiveHandler) {}
+
+    /**
+     * A packet listener implementation for handling sending, receiving, and error-related packet events globally.
+     * <p>
+     * This class allows for custom handling of packets traversing through the system by leveraging
+     * functional interfaces to define logic for sending, receiving, and error-handling scenarios.
+     * The class also defines a priority level which determines the order of execution relative to
+     * other listeners.
+     * <p>
+     * Components:
+     * - Sending handler: Logic to process outgoing packets.
+     * - Receiving handler: Logic to process incoming packets.
+     * - Error handler: Logic to handle exceptions occurring during packet processing.
+     * <p>
+     * The listener provides a default pass-through behavior if no handlers are defined or an exception is raised.
+     */
+    private record GlobalPacketListener(ListenerPriority priority, BiFunction<Connection, Packet<?>, PacketProcessingResult> sendHandler,
+                                        BiFunction<Connection, Packet<?>, PacketProcessingResult> receiveHandler,
+                                        BiFunction<Connection, Exception, Void> errorHandler) implements PacketListener {
+
+        @Override
+        public PacketProcessingResult onPacketSend(Connection connection, Packet<?> packet) {
+            if (sendHandler != null) {
+                try {
+                    return sendHandler.apply(connection, packet);
+                } catch (Exception e) {
+                    handleError(connection, e);
+                }
+            }
+            return PacketProcessingResult.pass();
+        }
+
+        @Override
+        public PacketProcessingResult onPacketReceive(Connection connection, Packet<?> packet) {
+            if (receiveHandler != null) {
+                try {
+                    return receiveHandler.apply(connection, packet);
+                } catch (Exception e) {
+                    handleError(connection, e);
+                }
+            }
+            return PacketProcessingResult.pass();
+        }
+
+        @Override
+        public void onPacketError(Connection connection, Packet<?> packet, Exception exception) {
+            handleError(connection, exception);
+        }
+
+        private void handleError(Connection connection, Exception exception) {
+            if (errorHandler != null) {
+                try {
+                    errorHandler.apply(connection, exception);
+                } catch (Exception ignored) {
+                    // Prevent recursive error handling
+                }
+            }
+        }
+    }
+
+    /**
+     * A specific implementation of {@link PacketListener} that processes packets using configured handlers
+     * and an optional error handler. It is designed to allow targeted processing of specific packet types
+     * with defined behaviors for sending and receiving packets.
+     * <p>
+     * This class relies on a map of packet types to handlers, enabling custom logic to be executed
+     * for each packet type during sending and receiving. If a handler is not present for a given packet type,
+     * the default behavior is to pass processing without modification.
+     * <p>
+     * The listener operates with a specified {@link ListenerPriority}, controlling the order in which
+     * it is invoked relative to other packet listeners.
+     * <p>
+     * Error handling is facilitated by an optional {@link BiFunction} that can define custom behavior
+     * when exceptions occur during packet handling operations.
+     */
+    private record SpecificPacketListener(ListenerPriority priority, Map<Class<? extends Packet<?>>, PacketTypeHandler> handlers,
+                                          BiFunction<Connection, Exception, Void> errorHandler) implements PacketListener {
+
+        @Override
+        public PacketProcessingResult onPacketSend(Connection connection, Packet<?> packet) {
+            PacketTypeHandler handler = handlers.get(packet.getClass());
+            if (handler != null && handler.sendHandler() != null) {
+                try {
+                    @SuppressWarnings("unchecked")
+                    BiFunction<Connection, Packet<?>, PacketProcessingResult> castedHandler =
+                        (BiFunction<Connection, Packet<?>, PacketProcessingResult>) handler.sendHandler();
+                    return castedHandler.apply(connection, packet);
+                } catch (Exception e) {
+                    handleError(connection, e);
+                }
+            }
+            return PacketProcessingResult.pass();
+        }
+
+        @Override
+        public PacketProcessingResult onPacketReceive(Connection connection, Packet<?> packet) {
+            PacketTypeHandler handler = handlers.get(packet.getClass());
+            if (handler != null && handler.receiveHandler() != null) {
+                try {
+                    @SuppressWarnings("unchecked")
+                    BiFunction<Connection, Packet<?>, PacketProcessingResult> castedHandler =
+                        (BiFunction<Connection, Packet<?>, PacketProcessingResult>) handler.receiveHandler();
+                    return castedHandler.apply(connection, packet);
+                } catch (Exception e) {
+                    handleError(connection, e);
+                }
+            }
+            return PacketProcessingResult.pass();
+        }
+
+        @Override
+        public void onPacketError(Connection connection, Packet<?> packet, Exception exception) {
+            handleError(connection, exception);
+        }
+
+        private void handleError(Connection connection, Exception exception) {
+            if (errorHandler != null) {
+                try {
+                    errorHandler.apply(connection, exception);
+                } catch (Exception ignored) {
+                    // Prevent recursive error handling
+                }
+            }
+        }
+    }
+}
diff --git a/net/gommehd/cheetah/network/packet/PacketListenerRegistry.java b/net/gommehd/cheetah/network/packet/PacketListenerRegistry.java
new file mode 100644
index 0000000000000000000000000000000000000000..6378cedca4675e9a114128cd62365ece83d309a7
--- /dev/null
+++ b/net/gommehd/cheetah/network/packet/PacketListenerRegistry.java
@@ -0,0 +1,399 @@
+package net.gommehd.cheetah.network.packet;
+
+import net.minecraft.network.protocol.Packet;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.function.Predicate;
+
+/**
+ * The {@code PacketListenerRegistry} class serves as a registry for managing listeners associated
+ * with various types of packets. This class supports both global and type-specific listeners, as well
+ * as listeners registered conditionally based on packet type predicates.
+ * <p>
+ * A singleton instance is provided to allow centralized management of packet listener registrations,
+ * retrievals, and removals across an application.
+ */
+public class PacketListenerRegistry {
+    private static final PacketListenerRegistry INSTANCE = new PacketListenerRegistry();
+
+    private final Map<Class<? extends Packet<?>>, List<PacketListener>> listeners = new ConcurrentHashMap<>();
+    private final List<PacketListener> globalListeners = new CopyOnWriteArrayList<>();
+    private final Map<PacketListener, Set<Class<? extends Packet<?>>>> listenerToTypes = new ConcurrentHashMap<>();
+    private final List<ConditionalListenerEntry> conditionalListeners = new CopyOnWriteArrayList<>();
+    private final Map<Class<? extends Packet<?>>, List<PacketListener>> conditionalListenerCache = new ConcurrentHashMap<>();
+
+    /**
+     * Returns the singleton instance of the PacketListenerRegistry class.
+     *
+     * @return the single instance of PacketListenerRegistry
+     */
+    public static PacketListenerRegistry getInstance() {
+        return INSTANCE;
+    }
+
+    /**
+     * Registers a listener to handle packets of the specified type.
+     * <p>
+     * The listener will be invoked whenever a packet of the given type is processed.
+     * Listeners are stored and managed internally in the registry. The order of invocation
+     * is determined by the listeners' priority.
+     * <p>
+     * The listener is also tracked internally for easier removal when unregistered.
+     *
+     * @param <T> the type of the packet to associate the listener with, must extend {@code Packet<?>}
+     * @param packetType the class object representing the type of packet the listener should handle; must not be null
+     * @param listener the listener to register; must not be null
+     * @throws NullPointerException if {@code packetType} or {@code listener} is null
+     */
+    public <T extends Packet<?>> void registerListener(Class<T> packetType, PacketListener listener) {
+        Objects.requireNonNull(packetType, "packetType cannot be null");
+        Objects.requireNonNull(listener, "listener cannot be null");
+
+        listeners.computeIfAbsent(packetType, k -> new CopyOnWriteArrayList<>())
+            .add(listener);
+        sortListenersByPriority(listeners.get(packetType));
+
+        // Track listener types for easier unregistering
+        listenerToTypes.computeIfAbsent(listener, k -> new HashSet<>()).add(packetType);
+    }
+
+    /**
+     * Registers a global listener that will be invoked for every packet type.
+     * <p>
+     * Global listeners are notified regardless of the specific type of packet
+     * being processed. The provided listener is added to the internal list of
+     * global listeners and sorted by priority.
+     *
+     * @param listener the {@link PacketListener} to register, must not be null
+     * @throws NullPointerException if the {@code listener} is null
+     */
+    public void registerGlobalListener(PacketListener listener) {
+        Objects.requireNonNull(listener, "listener cannot be null");
+
+        globalListeners.add(listener);
+        sortListenersByPriority(globalListeners);
+    }
+
+    /**
+     * Registers a listener for multiple packet types.
+     * <p>
+     * The specified listener will be notified for each packet type listed in
+     * the provided array of packet types. The listener must not be null, and
+     * the array of packet types must not contain null elements.
+     *
+     * @param listener the packet listener to register, must not be null
+     * @param packetTypes the packet types that the listener should handle
+     *                    must not be null and must not contain null elements
+     * @throws NullPointerException if listener or packetTypes is null
+     */
+    @SafeVarargs
+    public final void registerListener(PacketListener listener, Class<? extends Packet<?>>... packetTypes) {
+        Objects.requireNonNull(listener, "listener cannot be null");
+        Objects.requireNonNull(packetTypes, "packetTypes cannot be null");
+
+        for (Class<? extends Packet<?>> packetType : packetTypes) {
+            registerListener(packetType, listener);
+        }
+    }
+
+    /**
+     * Registers a conditional packet listener based on the provided condition.
+     * <p>
+     * The listener will only be invoked for packets that match the predicate
+     * specified by the condition parameter. Conditional listeners are sorted by
+     * priority, with higher priority listeners being invoked first.
+     *
+     * @param condition the condition to be checked against packet types; must not be null
+     * @param listener the packet listener to register; must not be null
+     * @throws NullPointerException if the condition or listener is null
+     */
+    public void registerConditionalListener(Predicate<Class<? extends Packet<?>>> condition, PacketListener listener) {
+        Objects.requireNonNull(condition, "condition cannot be null");
+        Objects.requireNonNull(listener, "listener cannot be null");
+
+        conditionalListeners.add(new ConditionalListenerEntry(condition, listener));
+
+        // Clear cache since we have a new conditional listener
+        conditionalListenerCache.clear();
+
+        // Sort by priority
+        conditionalListeners.sort((a, b) ->
+            Integer.compare(b.listener().priority().getPriority(), a.listener().priority().getPriority()));
+    }
+
+    /**
+     * Unregisters the specified {@link PacketListener} from all contexts in which it
+     * was previously registered. This includes global listeners, conditional listeners,
+     * and listeners for specific packet types.
+     *
+     * @param listener the {@link PacketListener} to unregister; must not be null
+     * @throws NullPointerException if the provided listener is null
+     */
+    public void unregisterListener(PacketListener listener) {
+        Objects.requireNonNull(listener, "listener cannot be null");
+
+        // Remove from global listeners
+        globalListeners.remove(listener);
+
+        // Remove from conditional listeners
+        conditionalListeners.removeIf(entry -> entry.listener().equals(listener));
+        conditionalListenerCache.clear(); // Clear cache since conditional listeners changed
+
+        // Remove from specific packet type listeners
+        Set<Class<? extends Packet<?>>> types = listenerToTypes.remove(listener);
+        if (types != null) {
+            for (Class<? extends Packet<?>> type : types) {
+                List<PacketListener> typeListeners = listeners.get(type);
+                if (typeListeners != null) {
+                    typeListeners.remove(listener);
+                    if (typeListeners.isEmpty()) {
+                        listeners.remove(type);
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Unregisters the specified listener for the given packet type.
+     * If the listener is no longer associated with any packet type,
+     * it is removed entirely from the mapping.
+     *
+     * @param packetType the class type of the packet for which the listener is to be unregistered
+     * @param listener the listener instance to be unregistered
+     * @throws NullPointerException if the packetType or listener is null
+     */
+    public void unregisterListener(Class<? extends Packet<?>> packetType, PacketListener listener) {
+        Objects.requireNonNull(packetType, "packetType cannot be null");
+        Objects.requireNonNull(listener, "listener cannot be null");
+
+        List<PacketListener> typeListeners = listeners.get(packetType);
+        if (typeListeners != null) {
+            typeListeners.remove(listener);
+            if (typeListeners.isEmpty()) {
+                listeners.remove(packetType);
+            }
+        }
+
+        Set<Class<? extends Packet<?>>> types = listenerToTypes.get(listener);
+        if (types != null) {
+            types.remove(packetType);
+            if (types.isEmpty()) {
+                listenerToTypes.remove(listener);
+            }
+        }
+    }
+
+    /**
+     * Retrieves a list of all packet listeners that are associated with the specified packet type.
+     * This method includes global listeners, type-specific listeners, and conditional listeners.
+     * It may also consider listeners registered for the superclass hierarchy of the given packet type.
+     * The resulting list is sorted by listener priority in descending order.
+     *
+     * @param packetType the class of the packet type for which listeners are being retrieved;
+     *                   must extend the {@code Packet} class and cannot be null.
+     * @return a sorted list of {@code PacketListener} objects that are associated with the
+     *         specified packet type, including all relevant types of listeners.
+     * @throws NullPointerException if the {@code packetType} is null.
+     */
+    @SuppressWarnings("unchecked")
+    public List<PacketListener> getListeners(Class<?> packetType) {
+        Objects.requireNonNull(packetType, "packetType cannot be null");
+
+        List<PacketListener> result = new ArrayList<>(globalListeners);
+
+        // Cast to the expected type - this is safe because we only register Packet subclasses
+        Class<? extends Packet<?>> safePacketType = (Class<? extends Packet<?>>) packetType;
+
+        // Add type-specific listeners
+        List<PacketListener> specificListeners = listeners.get(safePacketType);
+        if (specificListeners != null) {
+            result.addAll(specificListeners);
+        }
+
+        // Add conditional listeners (with caching)
+        List<PacketListener> conditionalListeners = getConditionalListenersForType(safePacketType);
+        result.addAll(conditionalListeners);
+
+        // Check inheritance hierarchy
+        Class<?> currentClass = packetType.getSuperclass();
+        while (currentClass != null && Packet.class.isAssignableFrom(currentClass)) {
+            @SuppressWarnings("unchecked")
+            List<PacketListener> parentListeners = listeners.get((Class<? extends Packet<?>>) currentClass);
+            if (parentListeners != null) {
+                result.addAll(parentListeners);
+            }
+            currentClass = currentClass.getSuperclass();
+        }
+
+        // Sort by priority
+        result.sort((a, b) -> Integer.compare(b.priority().getPriority(), a.priority().getPriority()));
+        return result;
+    }
+
+    /**
+     * Retrieves a list of PacketListener objects that match the specified packet type
+     * by evaluating their conditions. If the result is already cached, it retrieves
+     * it from the cache; otherwise, it evaluates the conditions, caches the result,
+     * and then returns it.
+     *
+     * @param packetType the class type of the packet for which the matching listeners
+     *                   are to be retrieved
+     * @return a list of PacketListener instances that are conditionally registered
+     *         and match the specified packet type
+     */
+    private List<PacketListener> getConditionalListenersForType(Class<? extends Packet<?>> packetType) {
+        // Check cache first
+        List<PacketListener> cached = conditionalListenerCache.get(packetType);
+        if (cached != null) {
+            return cached;
+        }
+
+        // Evaluate conditions and build result
+        List<PacketListener> result = new ArrayList<>();
+        for (ConditionalListenerEntry entry : conditionalListeners) {
+            if (entry.condition().test(packetType)) {
+                result.add(entry.listener());
+            }
+        }
+
+        // Cache the result
+        conditionalListenerCache.put(packetType, result);
+        return result;
+    }
+
+    /**
+     * Retrieves a set of all registered packet listeners.
+     * <p>
+     * This includes:
+     * - Global listeners that are invoked for every packet type.
+     * - Type-specific listeners registered for particular packet types.
+     * - Conditional listeners that match specific conditions.
+     * <p>
+     * The returned set includes all currently registered listeners, regardless of how they were registered.
+     *
+     * @return a set of all registered listeners, never null but may be empty.
+     */
+    public Set<PacketListener> getAllListeners() {
+        Set<PacketListener> result = new HashSet<>(globalListeners);
+        listeners.values().forEach(result::addAll);
+
+        // Add conditional listeners
+        for (ConditionalListenerEntry entry : conditionalListeners) {
+            result.add(entry.listener());
+        }
+
+        return result;
+    }
+
+    /**
+     * Retrieves the set of all registered packet types in the registry.
+     *
+     * @return a set of packet types (classes) for which listeners are registered, never null but may be empty
+     */
+    public Set<Class<? extends Packet<?>>> getRegisteredPacketTypes() {
+        return new HashSet<>(listeners.keySet());
+    }
+
+    /**
+     * Checks if the specified listener is currently registered in the registry.
+     * <p>
+     * A listener can be registered as a global listener, associated with specific
+     * packet types, or as a conditional listener based on predicates.
+     *
+     * @param listener the packet listener to check for registration; must not be null
+     * @return true if the listener is registered, false otherwise
+     * @throws NullPointerException if the listener is null
+     */
+    public boolean isListenerRegistered(PacketListener listener) {
+        Objects.requireNonNull(listener, "listener cannot be null");
+
+        if (globalListeners.contains(listener) || listenerToTypes.containsKey(listener)) {
+            return true;
+        }
+
+        // Check conditional listeners
+        return conditionalListeners.stream()
+            .anyMatch(entry -> entry.listener().equals(listener));
+    }
+
+    /**
+     * Clears all registered packet listeners and associated data.
+     * <p>
+     * This method effectively resets the state of the registry, removing:
+     * - All type-specific listeners.
+     * - All global listeners.
+     * - All listeners registered via predicates (conditional listeners).
+     * - Cached data related to conditional listeners.
+     * <p>
+     * After calling this method, no listeners will remain registered in the registry.
+     */
+    public void clear() {
+        listeners.clear();
+        globalListeners.clear();
+        listenerToTypes.clear();
+        conditionalListeners.clear();
+        conditionalListenerCache.clear();
+    }
+
+    /**
+     * Returns statistics about the current state of the registry, including conditional listeners.
+     *
+     * @return registry statistics, never null
+     */
+    public RegistryStats getStats() {
+        int totalSpecificListeners = listeners.values().stream().mapToInt(List::size).sum();
+        return new RegistryStats(
+            globalListeners.size(),
+            totalSpecificListeners,
+            listeners.size(),
+            getAllListeners().size(),
+            conditionalListeners.size()
+        );
+    }
+
+    /**
+     * Sorts the given list of PacketListener objects in descending order based on their priority.
+     *
+     * @param listeners the list of PacketListener objects to be sorted
+     */
+    private void sortListenersByPriority(List<PacketListener> listeners) {
+        listeners.sort((a, b) -> Integer.compare(b.priority().getPriority(), a.priority().getPriority()));
+    }
+
+    /**
+     * A record representing statistics about the current state of a packet listener registry.
+     * Contains various metrics related to registered listeners and packet types.
+     *
+     * @param globalListeners      the number of global listeners registered in the registry.
+     * @param specificListeners    the number of type-specific listeners registered.
+     * @param registeredPacketTypes the number of unique packet types that have listeners.
+     * @param uniqueListeners       the number of unique listeners (shared across global, specific, and conditional).
+     * @param conditionalListeners  the number of conditional listeners registered.
+     */
+    public record RegistryStats(int globalListeners, int specificListeners, int registeredPacketTypes,
+                                    int uniqueListeners, int conditionalListeners) {}
+
+    /**
+     * Represents an entry in the {@code PacketListenerRegistry} that associates a
+     * conditional predicate with a specific {@code PacketListener}.
+     * <p>
+     * This record is used for registering conditional listeners, where a listener will only
+     * handle packets of types that satisfy the given condition.
+     * <p>
+     * The condition is specified as a {@code Predicate} applied to the {@code Class} type of
+     * the packet, allowing fine-grained control over which packets the listener should handle.
+     * <p>
+     * It is an immutable data structure designed to store the pairing of a condition and
+     * its corresponding listener for efficient processing.
+     * <p>
+     * Fields:
+     * - {@code condition}: A {@code Predicate} that tests the class type of packets.
+     * - {@code listener}: A {@code PacketListener} that will handle packets matching the condition.
+     */
+    private record ConditionalListenerEntry(
+        Predicate<Class<? extends Packet<?>>> condition,
+        PacketListener listener
+    ) {}
+}
diff --git a/net/minecraft/network/Connection.java b/net/minecraft/network/Connection.java
index 53d54aa67affc629424dbbc0f9678292734c559e..585288229e403120a88fbc81987fa126ff8411f7 100644
--- a/net/minecraft/network/Connection.java
+++ b/net/minecraft/network/Connection.java
@@ -308,10 +308,54 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         }
     }
 
+    @SuppressWarnings("unchecked")
     private static <T extends PacketListener> void genericsFtw(Packet<T> packet, PacketListener listener) {
+        // Cheetah start - packet listener api
+        net.gommehd.cheetah.network.packet.PacketListenerRegistry registry =
+            net.gommehd.cheetah.network.packet.PacketListenerRegistry.getInstance();
+        java.util.List<net.gommehd.cheetah.network.packet.PacketListener> packetListeners =
+            registry.getListeners(packet.getClass());
+
+        // Get the connection instance from context - this is a bit of a hack but necessary
+        Connection connection = getCurrentConnection(listener);
+
+        // Call packet receive listeners
+        for (net.gommehd.cheetah.network.packet.PacketListener packetListener : packetListeners) {
+            try {
+                net.gommehd.cheetah.network.packet.PacketListener.PacketProcessingResult result =
+                    packetListener.onPacketSend(connection, packet);
+
+                if (result.result() == net.gommehd.cheetah.network.packet.PacketListener.PacketResult.MODIFIED) {
+                    packet = (net.minecraft.network.protocol.Packet<T>) result.modifiedPacket();
+                } else if (result.result() == net.gommehd.cheetah.network.packet.PacketListener.PacketResult.CANCEL) {
+                    return; // Skip packet processing
+                }
+            } catch (Exception e) {
+                LOGGER.warn("Error in packet receive listener for {}", packet.getClass().getSimpleName(), e);
+                try {
+                    packetListener.onPacketError(connection, packet, e);
+                } catch (Exception errorHandlerException) {
+                    LOGGER.error("Error in packet error handler", errorHandlerException);
+                }
+            }
+        }
+        // Cheetah end - packet listener api
         packet.handle((T)listener);
     }
 
+    // Cheetah start - packet listener api
+    // Helper method to get Connection from PacketListener context
+    @org.jspecify.annotations.Nullable
+    private static Connection getCurrentConnection(PacketListener listener) {
+        if (listener instanceof net.minecraft.server.network.ServerCommonPacketListenerImpl serverListener) {
+            return serverListener.connection;
+        }
+        // For other listener types, try to find connection through reflection or other means
+        // This is implementation-specific and may need adjustment based on your server version
+        return null;
+    }
+    // Cheetah end - packet listener api
+
     private void validateListener(ProtocolInfo<?> protocolInfo, PacketListener packetListener) {
         Objects.requireNonNull(packetListener, "packetListener");
         PacketFlow packetFlow = packetListener.flow();
@@ -485,30 +529,240 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
             packet.onPacketDispatchFinish(player, null);
             return;
         }
-        try {
-        final ChannelFuture channelFuture;
-        // Paper end - Optimize network
-        if (sendListener != null) {
-            channelFuture = flush ? this.channel.writeAndFlush(packet) : this.channel.write(packet); // Paper - Optimize network
-            channelFuture.addListener(sendListener);
-        } else if (flush) {
-            channelFuture = this.channel.writeAndFlush(packet, this.channel.voidPromise()); // Paper - Optimize network
+        // Cheetah start - packet listener api
+        net.gommehd.cheetah.network.packet.PacketListenerRegistry registry =
+            net.gommehd.cheetah.network.packet.PacketListenerRegistry.getInstance();
+
+        // Handle bundle packets specially - process sub-packets individually for listeners
+        if (packet instanceof net.minecraft.network.protocol.BundlePacket<?> bundlePacket) {
+            // Process each sub-packet through listeners and collect modified/non-cancelled packets
+            java.util.List<Packet<?>> processedSubPackets = new java.util.ArrayList<>();
+
+            for (Packet<?> subPacket : bundlePacket.subPackets()) {
+                java.util.List<net.gommehd.cheetah.network.packet.PacketListener> subPacketListeners =
+                    registry.getListeners(subPacket.getClass());
+
+                Packet<?> currentSubPacket = subPacket;
+                boolean subCancelled = false;
+
+                // Call packet send listeners for sub-packet
+                for (net.gommehd.cheetah.network.packet.PacketListener packetListener : subPacketListeners) {
+                    try {
+                        net.gommehd.cheetah.network.packet.PacketListener.PacketProcessingResult result =
+                            packetListener.onPacketSend(this, currentSubPacket);
+
+                        if (result.result() == net.gommehd.cheetah.network.packet.PacketListener.PacketResult.CANCEL) {
+                            subCancelled = true;
+                            break;
+                        } else if (result.result() == net.gommehd.cheetah.network.packet.PacketListener.PacketResult.MODIFIED) {
+                            currentSubPacket = result.modifiedPacket();
+                        }
+                    } catch (Exception e) {
+                        LOGGER.warn("Error in packet send listener for bundle sub-packet {}",
+                            currentSubPacket.getClass().getSimpleName(), e);
+                        try {
+                            packetListener.onPacketError(this, currentSubPacket, e);
+                        } catch (Exception errorHandlerException) {
+                            LOGGER.error("Error in packet error handler", errorHandlerException);
+                        }
+                    }
+                }
+
+                // Only add the sub-packet to processed list if not cancelled
+                if (!subCancelled) {
+                    processedSubPackets.add(currentSubPacket);
+                }
+            }
+
+            // If all sub-packets were cancelled, cancel the entire bundle
+            if (processedSubPackets.isEmpty()) {
+                if (packet.hasFinishListener()) {
+                    packet.onPacketDispatchFinish(player, null);
+                }
+                if (sendListener != null) {
+                    io.netty.channel.ChannelFuture completedFuture = this.channel.newSucceededFuture();
+                    completedFuture.addListener(sendListener);
+                }
+                return;
+            }
+
+            // Create a new bundle packet with processed sub-packets if any were modified/cancelled
+            if (processedSubPackets.size() != getBundleSubPacketCount(bundlePacket) || hasAnySubPacketBeenModified(bundlePacket, processedSubPackets)) {
+                // Reconstruct the bundle with the processed sub-packets
+                if (packet instanceof net.minecraft.network.protocol.game.ClientboundBundlePacket) {
+                    @SuppressWarnings("unchecked")
+                    java.util.List<Packet<? super net.minecraft.network.protocol.game.ClientGamePacketListener>> typedSubPackets =
+                        (java.util.List<Packet<? super net.minecraft.network.protocol.game.ClientGamePacketListener>>) (java.util.List<?>) processedSubPackets;
+                    packet = new net.minecraft.network.protocol.game.ClientboundBundlePacket(typedSubPackets);
+                }
+                // Add support for other bundle packet types if needed in the future
+            }
+
+            // Also process the bundle packet itself for listeners that might be interested in the bundle
+            java.util.List<net.gommehd.cheetah.network.packet.PacketListener> bundleListeners =
+                registry.getListeners(packet.getClass());
+
+            boolean bundleCancelled = false;
+            for (net.gommehd.cheetah.network.packet.PacketListener packetListener : bundleListeners) {
+                try {
+                    net.gommehd.cheetah.network.packet.PacketListener.PacketProcessingResult result =
+                        packetListener.onPacketSend(this, packet);
+
+                    if (result.result() == net.gommehd.cheetah.network.packet.PacketListener.PacketResult.MODIFIED) {
+                        packet = result.modifiedPacket();
+                    } else if (result.result() == net.gommehd.cheetah.network.packet.PacketListener.PacketResult.CANCEL) {
+                        bundleCancelled = true;
+                        break;
+                    }
+                } catch (Exception e) {
+                    LOGGER.warn("Error in packet send listener for bundle {}", packet.getClass().getSimpleName(), e);
+                    try {
+                        packetListener.onPacketError(this, packet, e);
+                    } catch (Exception errorHandlerException) {
+                        LOGGER.error("Error in packet error handler", errorHandlerException);
+                    }
+                }
+            }
+
+            if (bundleCancelled) {
+                if (packet.hasFinishListener()) {
+                    packet.onPacketDispatchFinish(player, null);
+                }
+                if (sendListener != null) {
+                    io.netty.channel.ChannelFuture completedFuture = this.channel.newSucceededFuture();
+                    completedFuture.addListener(sendListener);
+                }
+                return;
+            }
         } else {
-            channelFuture = this.channel.write(packet, this.channel.voidPromise()); // Paper - Optimize network
-        }
+            // Handle non-bundle packets as before
+            java.util.List<net.gommehd.cheetah.network.packet.PacketListener> packetListeners =
+                registry.getListeners(packet.getClass());
 
-        // Paper start - Optimize network
-        if (packet.hasFinishListener()) {
-            channelFuture.addListener((ChannelFutureListener) future -> packet.onPacketDispatchFinish(player, future));
+            // Call packet send listeners
+            boolean cancelled = false;
+            for (net.gommehd.cheetah.network.packet.PacketListener packetListener : packetListeners) {
+                try {
+                    net.gommehd.cheetah.network.packet.PacketListener.PacketProcessingResult result =
+                        packetListener.onPacketSend(this, packet);
+
+                    if (result.result() == net.gommehd.cheetah.network.packet.PacketListener.PacketResult.MODIFIED) {
+                        packet = result.modifiedPacket();
+                    } else if (result.result() == net.gommehd.cheetah.network.packet.PacketListener.PacketResult.CANCEL) {
+                        cancelled = true;
+                        break;
+                    }
+                } catch (Exception e) {
+                    LOGGER.warn("Error in packet send listener for {}", packet.getClass().getSimpleName(), e);
+                    try {
+                        packetListener.onPacketError(this, packet, e);
+                    } catch (Exception errorHandlerException) {
+                        LOGGER.error("Error in packet error handler", errorHandlerException);
+                    }
+                }
+            }
+
+            if (cancelled) {
+                if (packet.hasFinishListener()) {
+                    packet.onPacketDispatchFinish(player, null);
+                }
+                if (sendListener != null) {
+                    io.netty.channel.ChannelFuture completedFuture = this.channel.newSucceededFuture();
+                    completedFuture.addListener(sendListener);
+                }
+                return;
+            }
         }
+        final Packet<?> finalPacket = packet;
+        // Cheetah end - packet listener api
+
+        try {
+            final ChannelFuture channelFuture;
+            // Paper end - Optimize network
+            if (sendListener != null) {
+                channelFuture = flush ? this.channel.writeAndFlush(packet) : this.channel.write(packet); // Paper - Optimize network
+                channelFuture.addListener(sendListener);
+            } else if (flush) {
+                channelFuture = this.channel.writeAndFlush(packet, this.channel.voidPromise()); // Paper - Optimize network
+            } else {
+                channelFuture = this.channel.write(packet, this.channel.voidPromise()); // Paper - Optimize network
+            }
+
+            // Paper start - Optimize network
+            if (packet.hasFinishListener()) {
+                channelFuture.addListener((ChannelFutureListener) future -> finalPacket.onPacketDispatchFinish(player, future)); // Cheetah - packet listener api
+            }
         } catch (final Exception e) {
             LOGGER.error("NetworkException: {}", player, e);
+
+            // Cheetah start - packet listener api
+            // Handle error notifications for bundle packets
+            if (finalPacket instanceof net.minecraft.network.protocol.BundlePacket<?> bundlePacket) {
+                // Notify listeners about error for each sub-packet
+                for (Packet<?> subPacket : bundlePacket.subPackets()) {
+                    java.util.List<net.gommehd.cheetah.network.packet.PacketListener> subPacketListeners =
+                        registry.getListeners(subPacket.getClass());
+                    for (net.gommehd.cheetah.network.packet.PacketListener packetListener : subPacketListeners) {
+                        try {
+                            packetListener.onPacketError(this, subPacket, e);
+                        } catch (Exception errorHandlerException) {
+                            LOGGER.error("Error in packet error handler", errorHandlerException);
+                        }
+                    }
+                }
+            }
+
+            // Notify packet listeners about the error for the main packet
+            java.util.List<net.gommehd.cheetah.network.packet.PacketListener> packetListeners =
+                registry.getListeners(finalPacket.getClass());
+            for (net.gommehd.cheetah.network.packet.PacketListener packetListener : packetListeners) {
+                try {
+                    packetListener.onPacketError(this, finalPacket, e);
+                } catch (Exception errorHandlerException) {
+                    LOGGER.error("Error in packet error handler", errorHandlerException);
+                }
+            }
+            // Cheetah end - packet listener api
+
             this.disconnect(Component.translatable("disconnect.genericReason", "Internal Exception: " + e.getMessage()));
             packet.onPacketDispatchFinish(player, null);
         }
         // Paper end - Optimize network
     }
 
+    // Cheetah start - packet listener api - Helper methods for bundle packet handling
+    private int getBundleSubPacketCount(net.minecraft.network.protocol.BundlePacket<?> bundlePacket) {
+        int count = 0;
+        for (Packet<?> ignored : bundlePacket.subPackets()) {
+            count++;
+        }
+        return count;
+    }
+
+    private boolean hasAnySubPacketBeenModified(net.minecraft.network.protocol.BundlePacket<?> originalBundle,
+                                                java.util.List<Packet<?>> processedSubPackets) {
+        // Convert original sub-packets to a list for comparison
+        java.util.List<Packet<?>> originalSubPackets = new java.util.ArrayList<>();
+        for (Packet<?> subPacket : originalBundle.subPackets()) {
+            originalSubPackets.add(subPacket);
+        }
+
+        // Check if lists have different sizes
+        if (originalSubPackets.size() != processedSubPackets.size()) {
+            return true;
+        }
+
+        // Check if any packet reference has changed (indicating modification)
+        for (int i = 0; i < originalSubPackets.size(); i++) {
+            if (originalSubPackets.get(i) != processedSubPackets.get(i)) {
+                return true; // Reference inequality means modification occurred
+            }
+        }
+
+        return false;
+    }
+    // Cheetah end - packet listener api
+
     public void flushChannel() {
         if (this.isConnected()) {
             this.flush();
